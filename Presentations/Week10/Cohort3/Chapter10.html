<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Advanced R Chapter 10</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sam Bryce-Smith, R4DS Reading Group, Cohort 3" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Advanced R Chapter 10
## Function Factories
### Sam Bryce-Smith, R4DS Reading Group, Cohort 3

---







# What are function factories?

- Function factories are functions that produce functions
- *power1* - function factory
- *square* &amp; *cube* - 'manufactured' function produced by function factory (and assigned to name)


```r
power1 &lt;- function(exponent) {
  function(x) {
    x ^ exponent
  }
}

square &lt;- power1(2)
cube &lt;- power1(3)

square(2)
```

```
## [1] 4
```

```r
cube(2)
```

```
## [1] 8
```

---

### How do they work? A recap on key concepts of functions

- How does R find the value of exponent?

- A new environment is created every time a function is called
  - Function is executed inside this environment (execution environment)
  - Binds/captures the enclosing environment when it is created (function environment)
    - (By default this is the current environment)
  

```r
y &lt;- 1
f &lt;- function(x) x + y
fn_env(f)
```

```
## &lt;environment: R_GlobalEnv&gt;
```

```r
env_print(f)
```

```
## &lt;environment: global&gt;
## parent: &lt;environment: package:purrr&gt;
## bindings:
##  * x: &lt;named list&gt;
##  * y: &lt;dbl&gt;
##  * f1: &lt;fn&gt;
##  * power1: &lt;fn&gt;
##  * z: &lt;dbl&gt;
##  * f2: &lt;fn&gt;
##  * power2: &lt;fn&gt;
##  * base_bins: &lt;fn&gt;
##  * pick: &lt;fn&gt;
##  * cube: &lt;fn&gt;
##  * core: &lt;gg&gt;
##  * boot_permute: &lt;fn&gt;
##  * .Random.seed: &lt;int&gt;
##  * g1: &lt;fn&gt;
##  * g2: &lt;fn&gt;
##  * binwidth_bins: &lt;fn&gt;
##  * expected_q3: &lt;named list&gt;
##  * funs: &lt;named list&gt;
##  * sd: &lt;dbl&gt;
##  * df: &lt;df[,2]&gt;
##    * ... with 15 more bindings
```

```r
#&gt; &lt;environment: R_GlobalEnv&gt;
```

- Lexical scoping - heirarchy to finding names
  - Current function (exection environment)
  - Where function was defined (environment enclosing function, function environment)
  - Further levels up (all the way up to global environment)
  
  
---

# How do they work? A recap on key concepts of functions


```r
power1 &lt;- function(exponent) {
  function(x) {
    x ^ exponent
  }
}

square &lt;- power1(2)
cube &lt;- power1(3)

square(2)
```

```
## [1] 4
```

```r
cube(2)
```

```
## [1] 8
```

- power1(2) creates execution environment (where exponent = 2)
- function(x) is created, and binds the environment enclosing it (the execution environment of power1(2))


---
# Environments

square and cube have the same function body, but two different environments.


```r
square
```

```
## function(x) {
##     x ^ exponent
##   }
## &lt;environment: 0x55877f7a2948&gt;
```

```r
cube
```

```
## function(x) {
##     x ^ exponent
##   }
## &lt;bytecode: 0x55877efa3140&gt;
## &lt;environment: 0x5587808969d0&gt;
```

---

# square and cube have bindings to exponent


```r
env_print(square)
```

```
## &lt;environment: 0x55877f7a2948&gt;
## parent: &lt;environment: global&gt;
## bindings:
##  * exponent: &lt;dbl&gt;
```

```r
env_print(cube)
```

```
## &lt;environment: 0x5587808969d0&gt;
## parent: &lt;environment: global&gt;
## bindings:
##  * exponent: &lt;dbl&gt;
```

Square and cube have bindings to exponent - defined in the execution environment of power1 (the function factory)

---

# What are values of exponent in square and cube?

use *rlang::fn_env()* to extract the function environment


```r
fn_env(square)$exponent
```

```
## [1] 2
```

```r
fn_env(cube)$exponent
```

```
## [1] 3
```

exponent is bound to different values in each case

---

# Be extra careful with function factories and lazy evaluation

**Lazy evaluation** - R only evaluates arguments when they are needed 


```r
x &lt;- 2
square &lt;- power1(x)
x &lt;- 3

square(2)
```

```
## [1] 8
```

- Value bound to x has changed between calling the *factory function* (to create the function) and calling the *manunfactured function* (when value of x is needed and looked up).
---

# Be sure to use (the) force()

If the argument is used by the manufactured function, you should force it's evaluation with **force()**


```r
power2 &lt;- function(exp) {
  force(exp)
  function(x) {
    x ^ exp
  }
}

x &lt;- 2
square &lt;- power2(x)
x &lt;- 3
square(2)
```

```
## [1] 4
```
---

# Stateful functions

- Function factories let you maintain state across invocations
  - Manufactured functions have their own, constant enclosing environment
  
`&lt;-` - binds a value to a name in the **current environment**
`&lt;&lt;-` - *rebinds** an existing name found in a **parent environment**


```r
new_counter &lt;- function() {
  i &lt;- 0
  
  function() {
    i &lt;&lt;- i + 1
    i
  }
}

counter_one &lt;- new_counter()
counter_two &lt;- new_counter()

counter_one()
```

```
## [1] 1
```

```r
counter_one()
```

```
## [1] 2
```

```r
counter_two()
```

```
## [1] 1
```

- Manufactured functions have their own unique enclosing environment 
- counter_one and counter_two will have independent counnts
- Best used in moderation

---
# Garbage collection

As manufactured functions bind the execution environment of the function factory, temporary objects that are no longer needed won't be removed.

You should explicitly use **rm()** to unbind objects in function factories


```r
f1 &lt;- function(n) {
  x &lt;- runif(n)
  m &lt;- mean(x)
  function() m
}

g1 &lt;- f1(1e6)
lobstr::obj_size(g1)
```

```
## 8,013,496 B
```

```r
#&gt; 8,013,104 B

f2 &lt;- function(n) {
  x &lt;- runif(n)
  m &lt;- mean(x)
  rm(x)
  function() m
}

g2 &lt;- f2(1e6)
lobstr::obj_size(g2)
```

```
## 13,336 B
```

```r
#&gt; 12,944 B
```

# 10.2.6 Exercises

1. Why is it better to force(x) instead of just x?


```r
force
```

```
## function (x) 
## x
## &lt;bytecode: 0x558777fe47c8&gt;
## &lt;environment: namespace:base&gt;
```

```r
#&gt; function (x) 
#&gt; x
#&gt; &lt;bytecode: 0xce23a0&gt;
#&gt; &lt;environment: namespace:base&gt;
```

My answer - being explicit can help with clarity of code... 


```r
power2 &lt;- function(exp) {
  force(exp)
  function(x) {
    x ^ exp
  }
}

x &lt;- 2
square &lt;- power2(x)
x &lt;- 3
square(2)
```

```
## [1] 4
```

```r
power2_just_exp &lt;- function(exp) {
  exp
  function(x) {
    x ^ exp
  }
}

z &lt;- 2
square_just_exp &lt;- power2_just_exp(z)
z &lt;- 3
square_just_exp(2)
```

```
## [1] 4
```

---
# 10.2.6 Exercises

2. What do approxfun() and ecdf() do?


---

---
# 10.2.6 Exercises

3. Create a function pick() that takes an index, i, as an argument and returns a function with an argument x that subsets x with i.

My answer -
want i to be input to function factory
Want to make sure i is evaluated when function is called
Want manufacured function to have binding to i


```r
pick &lt;- function(i) {
  force(i)
  
  function(x) {
    x[[i]]
  }
}


expected_q3 = lapply(mtcars, function(x) x[[5]])
identical(expected_q3,
          lapply(mtcars, pick(5)))
```

```
## [1] TRUE
```

---

# 10.2.6 Exercises

4. Create a function that creates functions that compute the ith central moment of a numeric vector.



---

# 10.2.6 Exercises

5. What happens if you donâ€™t use a closure? Make predictions, then verify with the code below.

The function will still count the number of invocations, but i isn't captured in enclosing environment of new_counter2 (it's in global environment)

I could modify i without having to call the function



```r
i &lt;- 0
new_counter2 &lt;- function() {
  i &lt;&lt;- i + 1
  i
}

new_counter2()
```

```
## [1] 1
```

```r
new_counter2()
```

```
## [1] 2
```

```r
i &lt;- 0
new_counter2()
```

```
## [1] 1
```

---

# 10.2.6 Exercises

6. What happens if you use &lt;- instead of &lt;&lt;-? Make predictions, then verify with the code below.

Every time the function is called, i is updated in the execution environment only. So every time time the function is called again, i is still 0 (the enclosing environment for the manufactured function is constant unless bindings are updated with &lt;&lt;-)

This should return 1 every time


```r
new_counter3 &lt;- function() {
  i &lt;- 0
  function() {
    i &lt;- i + 1
    i
  }
}
```

---
# Applications of function factories - ggplot2

ggplot2 &amp; scales provide nice opportunity to use function factories

*scales* provides functions to control details of axes and legends
- the formatter functions are function factories 


```r
y &lt;- c(12345, 123456, 1234567)
comma_format()(y)
```

```
## [1] "12,345"    "123,456"   "1,234,567"
```

```r
#&gt; [1] "12,345"    "123,456"   "1,234,567"

number_format(scale = 1e-3, suffix = " K")(y)
```

```
## [1] "12 K"    "123 K"   "1 235 K"
```

```r
#&gt; [1] "12 K"    "123 K"   "1 235 K"
```

---

# ggplot scales accept functions for the label argument



```r
df &lt;- data.frame(x = 1, y = y)
core &lt;- ggplot(df, aes(x, y)) + 
  geom_point() + 
  scale_x_continuous(breaks = 1, labels = NULL) +
  labs(x = NULL, y = NULL)
  
core
```

![](Chapter10_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

```r
core + scale_y_continuous(
  labels = comma_format()
)
```

![](Chapter10_files/figure-html/unnamed-chunk-9-2.png)&lt;!-- --&gt;

```r
core + scale_y_continuous(
  labels = number_format(scale = 1e-3, suffix = " K")
)
```

![](Chapter10_files/figure-html/unnamed-chunk-9-3.png)&lt;!-- --&gt;

```r
core + scale_y_continuous(
  labels = scientific_format()
)
```

![](Chapter10_files/figure-html/unnamed-chunk-9-4.png)&lt;!-- --&gt;

---

# Histograms - binwidth 
- *geom_histogram(binwidth)* can accpet a function as the binwidth argument
- This allows you to have **different binwidths for plots in different facets**


```r
# construct some sample data with very different numbers in each cell
sd &lt;- c(1, 5, 15)
n &lt;- 100

df &lt;- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = 2) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```

![](Chapter10_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;


Given the wide variability in counts between 1, 5 &amp; 15, it is less clear to see the counts in 5 &amp; 15...

---

# Histograms - binwidth

Use a function factory to get approximately the same number of observations in each bin
- Input desired number of bins
- Output function taking a numeric vector that returns a binwidth


```r
binwidth_bins &lt;- function(n) {
  force(n)
  
  function(x) {
    (max(x) - min(x)) / n
  }
}
```

---

# Histograms - binwidth


```r
ggplot(df, aes(x)) + 
  geom_histogram(binwidth = binwidth_bins(20)) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```

![](Chapter10_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

---

# Histograms - binwidth

- `class.Sturges()`, `nclass.scott()` and `nclass.FD()` are base functions to find optimal binwidth
- Can wrap around these with a function factory


```r
base_bins &lt;- function(type) {
  fun &lt;- switch(type,
    Sturges = nclass.Sturges,
    scott = nclass.scott,
    FD = nclass.FD,
    stop("Unknown type", call. = FALSE)
  )
  
  function(x) {
    (max(x) - min(x)) / fun(x)
  }
}
```

---

# Histograms - binwidth


```r
ggplot(df, aes(x)) + 
  geom_histogram(binwidth = base_bins("FD")) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```

![](Chapter10_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

---

# Function factories for statistics

- Further examples for using function factories
- The Box-Cox transformation
- Bootstrap resampling
- Maximum likelihood estimation

(Disclaimer - I only dove into bootstrap resampling, but I think it demonstrates previous concepts nicely)

---

# Bootstrapping

- resampling method
- randomly sample with replacement (&amp; repeat numerous times)
- Can be used to estimate statistics about a population

---

# Bootstrapping


```r
boot_permute &lt;- function(df, var) {
  n &lt;- nrow(df)
  force(var)
  
  function() {
    col &lt;- df[[var]]
    col[sample(n, replace = TRUE)]
  }
}

boot_mtcars1 &lt;- boot_permute(mtcars, "mpg")
head(boot_mtcars1())
```

```
## [1] 13.3 14.7 32.4 21.4 19.2 15.8
```

```r
#&gt; [1] 16.4 22.8 22.8 22.8 16.4 19.2
head(boot_mtcars1())
```

```
## [1] 21.0 22.8 16.4 26.0 21.0 21.5
```

```r
#&gt; [1] 17.8 18.7 30.4 30.4 16.4 21.0
```

---

## Useful for parametric bootstrap
- Fit model once, then explicitly remove temporary object (linear model objects are large)


```r
boot_model &lt;- function(df, formula) {
  mod &lt;- lm(formula, data = df)
  fitted &lt;- unname(fitted(mod))
  resid &lt;- unname(resid(mod))
  rm(mod)

  function() {
    fitted + sample(resid)
  }
} 

boot_mtcars2 &lt;- boot_model(mtcars, mpg ~ wt)
head(boot_mtcars2())
```

```
## [1] 21.39959 23.66597 31.75866 22.45261 17.80000 15.33090
```

```r
head(boot_mtcars2())
```

```
## [1] 24.45596 23.66597 25.03800 20.40251 25.32212 16.18225
```

---

# 10.4.4 Exercises

I haven't tackled any of these - sorry!

---

### Combining function factories with functionals

- Create many power functions by iterating over named list


```r
names &lt;- list(
  square = 2, 
  cube = 3, 
  root = 1/2, 
  cuberoot = 1/3, 
  reciprocal = -1
)
funs &lt;- purrr::map(names, power1)

funs$root(64)
```

```
## [1] 8
```

```r
funs$root
```

```
## function(x) {
##     x ^ exponent
##   }
## &lt;bytecode: 0x55877efa3140&gt;
## &lt;environment: 0x558786892de0&gt;
```

- Functions are stored in list *funs*
- calling function with prefix *funs$* could be annoying...

---
### How to avoid prefixing function call with funs$

- Can use *with()*


```r
with(funs, root(100))
```

```
## [1] 10
```
- Only temporary

- *attach()* &amp; *detach()* is longer lasting approach (but be careful)

```r
attach(funs)
```

```
## The following objects are masked _by_ .GlobalEnv:
## 
##     cube, square
```

```r
root(100)
```

```
## [1] 10
```

```r
detach(funs)
```

---

### How to avoid prefixing function call with funs$

- Copy functions to global environment with *rlang::env_bind()*
- (Pretty much permanent)


```r
rlang::env_bind(globalenv(), !!!funs)
root(100)
```

```
## [1] 10
```

- Can be unbound later (*rlang::env_unbind()*), but names could have been rebound in intervening period
  - Could end up deleting object not created by binding funs
  

```r
rlang::env_unbind(globalenv(), names(funs))
```

- more about quasiquotation - `!!!` - in **Section 19**...

---

# 10.5.1 - Exercises

Q - **Which of the following commands is equivalent to with(x, f(z))?**

- x$f(x$z).
- f(x$z).
- x$f(z).
- f(z).
- It depends.


My initial thoughts...

- If x is a list of functions as in previous example, then
  - `x$f(z)` would be my answer 


---

# 10.5.1 - Exercises

A - Depends on structure of `x`!
- if x is a dataframe, then `f(x$z)`
- if x is a list, then it could be any of the options!
    

```r
f &lt;- mean
z &lt;- 1
x &lt;- list(f = mean, z = 1)

identical(with(x, f(z)), x$f(x$z))
```

```
## [1] TRUE
```

```r
identical(with(x, f(z)), f(x$z))
```

```
## [1] TRUE
```

```r
identical(with(x, f(z)), x$f(z))
```

```
## [1] TRUE
```

```r
identical(with(x, f(z)), f(z))
```

```
## [1] TRUE
```

---

class: inverse, hide-logo

# Another Slide
This slide doesn't have a logo

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>
<style>
.logo {
  background-image: url(r4ds.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 110px;
  height: 128px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
